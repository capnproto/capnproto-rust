// Copyright (c) 2013-2015 Sandstorm Development Group, Inc. and contributors
// Licensed under the MIT License:
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

//! # Cap'n Proto Runtime Library
//!
//! This crate contains basic facilities for reading and writing
//! [Cap'n Proto](https://capnproto.org) messages in Rust. It is intended to
//! be used in conjunction with code generated by the
//! [capnpc-rust](https://github.com/capnproto/capnproto-rust/capnpc) crate.
//!
//! # Examples
//!
//! The following example shows how to send and process a simple RPC.
//! Specifically:
//!
//! ```capnproto
//! interface HelloWorld {
//!     helloWorld @0 (name: Text) -> (greeting: Text);
//! }
//! ```
//!
//! The first code block shows how to send the RPC, and process the
//! response, i.e., code that the client needs to implement.  The
//! second code block shows how the server processes the request, and
//! composes a response.
//!
//! ```
//! # type Result<T, E=Box<dyn std::error::Error>> = std::result::Result<T, E>;
//! use std::convert::TryInto;
//!
//! use capnp::capability::Promise;
//! use capnp::capability::Response;
//! use capnp::message::{self, TypedBuilder, TypedReader};
//!
//! // The module generated from `hello_world.capnp` by `capnpc`.
//! use capnp_testdata::hello_world_capnp;
//! // The `HelloWorld` interface.
//! use hello_world_capnp::hello_world;
//!
//! // An ergonomic wrapper to marshal the `HelloWorld::helloWorld` RPC.
//! fn hello_world(client: &mut hello_world::Client, name: &str)
//!     -> Result<Promise<Response<hello_world::hello_world_results::Owned>,
//!               capnp::Error>>
//! {
//!     // `client` is a capability referencing an object that
//!     // implements the `HelloWorld` interface.
//!
//!     // Create a `helloWorld` request.
//!     let mut request = client.hello_world_request();
//!
//!     // Set the parameters:
//!
//!     // `init_name` takes `request` by value, not by reference
//!     // for safety reasons.  This makes using these methods
//!     // a bit less convenient: you need to first reborrow the
//!     // value if you need to keep access to the original value.
//!     request.get().reborrow().init_name(name.len().try_into()?);
//!     request.get().set_name(name);
//!
//!     // This doesn't actually send the message.  It just returns a
//!     // promise (a Cap'n Proto-specific Future).  In an async
//!     // context you would do:
//!     //
//!     // ```
//!     // hello_world(client, name).await
//!     // ```
//!     Ok(request.send().promise)
//! }
//!
//! fn hello_world_response(response: Response<hello_world::hello_world_results::Owned>)
//!     -> Result<String>
//! {
//!     // We get a reference to the string.  We can't return the
//!     // reference, because `response` doesn't live long enough,
//!     // so we return a copy.  In general, a better strategy is
//!     // to process the response as much as possible in place to
//!     // minimize the amount of data that has to be copied.
//!
//!     // Note: Cap'n Proto only checks whether a pointer is valid
//!     // when we read the pointer.  As such, `get_greeting` returns
//!     // a result.
//!     let response: &str = response.get()?.get_greeting()?;
//!     Ok(response.into())
//! }
//! ```
//!
//! A possible server implementation:
//!
//! ```
//! # type Result<T, E=Box<dyn std::error::Error>> = std::result::Result<T, E>;
//! use capnp::capability::Promise;
//! use capnp_rpc::pry;
//!
//! // The module generated from `hello_world.capnp` by `capnpc`.
//! use capnp_testdata::hello_world_capnp;
//! // The `HelloWorld` interface.
//! use hello_world_capnp::hello_world;
//!
//! use capnp::message::{self, TypedBuilder, TypedReader};
//!
//! // The state associated with a "HelloWorld" object.
//! //
//! // In this case, the object doesn't have any state.  But, we still
//! // need a handle, so we use an empty struct.
//! struct HelloWorldServer {
//! }
//!
//! impl hello_world::Server for HelloWorldServer {
//!     fn hello_world(
//!         &mut self,
//!         params: hello_world::HelloWorldParams,
//!         mut results: hello_world::HelloWorldResults,
//!     ) -> Promise<(), ::capnp::Error> {
//!         // `pry!` is like `try!`, but for `Promise`s.  Once
//!         // `std::ops::Try` stabilizes, this can be replaced with a
//!         // normal `?`.
//!         let name = pry!(pry!(params.get()).get_name());
//!
//!         let message = format!("Hello, {}!", name);
//!
//!         results.get().init_greeting(message.len() as u32);
//!         results.get().set_greeting(&message);
//!
//!         Promise::ok(())
//!     }
//! }
//! ```
//!
//! A more complicated example where we pass and return a list of
//! strings.  Here we use the build-in [`text_list::Builder`] to
//! create the list of strings.
//!
//! ```
//! # type Result<T, E=Box<dyn std::error::Error>> = std::result::Result<T, E>;
//! use std::convert::TryInto;
//!
//! use capnp::capability::Promise;
//! use capnp::capability::Response;
//! use capnp::message::{self, TypedBuilder, TypedReader};
//!
//! // The module generated from `hello_world.capnp` by `capnpc`.
//! use capnp_testdata::hello_world_capnp;
//! // The `HelloWorld` interface.
//! use hello_world_capnp::hello_world;
//!
//! // An ergonomic wrapper to marshal the `HelloWorld::broadcastHello` RPC.
//! fn broadcast_hello(client: &mut hello_world::Client, names: &[&str])
//!     -> Result<Promise<Response<hello_world::broadcast_hello_results::Owned>,
//!               capnp::Error>>
//! {
//!     // `client` is a capability referencing an object that
//!     // implements the `HelloWorld` interface.
//!
//!     // Create a `broadcastHello` request.
//!     let mut request = client.broadcast_hello_request();
//!
//!     // Set the parameters:
//!
//!     // `init_names` takes `request` by value, not by reference
//!     // for safety reasons.  This makes using these methods
//!     // a bit less convenient: you need to first reborrow the
//!     // value if you need to keep access to the original value.
//!     request.get().reborrow().init_names(names.len().try_into()?);
//!     for (i, &name) in names.into_iter().enumerate() {
//!         let n = capnp::text::new_reader(name.as_bytes())?;
//!         request.get().reborrow().get_names()?.set(i as u32, n);
//!     }
//!
//!     // This doesn't actually send the message.  It just returns a
//!     // promise (a Cap'n Proto-specific Future).  In an async
//!     // context you would do:
//!     //
//!     // ```
//!     // broadcase_hello(client, &[ "Alice", "Bob" ]).await
//!     // ```
//!     Ok(request.send().promise)
//! }
//!
//! fn broadcast_hello_response(response: Response<hello_world::broadcast_hello_results::Owned>)
//!     -> Result<Vec<String>>
//! {
//!     // We get a reference to the strings.  We can't return a
//!     // reference, because `response` doesn't live long enough,
//!     // so we return a copy.  In general, a better strategy is
//!     // to process the response as much as possible in place to
//!     // minimize the amount of data that has to be copied.
//!
//!     // Note: Cap'n Proto only checks whether a pointer is valid
//!     // when we read the pointer.  As such, `get_greetings` and
//!     // the `capnp::text_list::Reader` iterator return `Result`s.
//!     let greetings = response.get()?.get_greetings()?;
//!     // A `capnp::text_list::Reader` conveniently provides an iterator.
//!     let greetings = greetings.iter()
//!         .map(|greeting: Result<&str, _>| {
//!             Ok(greeting?.into())
//!         })
//!         .collect::<Result<Vec<String>>>()?;
//!     Ok(greetings.into())
//! }
//! ```
//!
//! In the next example, we invoke a method, which returns a
//! capability to a new object:
//!
//! ```
//! # type Result<T, E=Box<dyn std::error::Error>> = std::result::Result<T, E>;
//! use std::convert::TryInto;
//!
//! use capnp::capability::Promise;
//! use capnp::capability::Response;
//! use capnp::message::{self, TypedBuilder, TypedReader};
//!
//! // The module generated from `hello_world.capnp` by `capnpc`.
//! use capnp_testdata::hello_world_capnp;
//! // The `HelloWorld` interface.
//! use hello_world_capnp::hello_world;
//!
//! // An ergonomic wrapper to marshal the `HelloWorld::broadcastHello` RPC.
//! fn connect(client: &mut hello_world::Client, name: &str)
//!     -> Result<Promise<Response<hello_world::connect_results::Owned>,
//!               capnp::Error>>
//! {
//!     // `client` is a capability referencing an object that
//!     // implements the `HelloWorld` interface.
//!
//!     // Create a `connect` request.
//!     let mut request = client.connect_request();
//!
//!     // Set the parameters:
//!
//!     // `init_connection` takes `request` by value, not by reference
//!     // for safety reasons.  This makes using these methods
//!     // a bit less convenient: you need to first reborrow the
//!     // value if you need to keep access to the original value.
//!     request.get().reborrow().init_name(name.len().try_into()?);
//!     request.get().reborrow().set_name(name);
//!
//!     // This doesn't actually send the message.  It just returns a
//!     // promise (a Cap'n Proto-specific Future).  In an async
//!     // context you would do:
//!     //
//!     // ```
//!     // connect(client, "Alice").await
//!     // ```
//!     Ok(request.send().promise)
//! }
//!
//! fn connect_response(response: Response<hello_world::connect_results::Owned>)
//!     -> Result<hello_world::connection::Client>
//! {
//!     Ok(response.get()?.get_connection()?)
//! }
//! ```

#![cfg_attr(feature = "rpc_try", feature(try_trait_v2))]
#![cfg_attr(not(feature = "std"), no_std)]

#[macro_use]
extern crate alloc;

pub mod any_pointer;
pub mod any_pointer_list;
pub mod capability;
pub mod capability_list;
pub mod constant;
pub mod data;
pub mod data_list;
pub mod enum_list;
pub mod io;
pub mod list_list;
pub mod message;
pub mod primitive_list;
pub mod private;
pub mod raw;
pub mod serialize;
pub mod serialize_packed;
pub mod struct_list;
pub mod text;
pub mod text_list;
pub mod traits;

use alloc::string::String;
use alloc::vec::Vec;

///
/// 8 bytes, aligned to an 8-byte boundary.
///
/// Internally, capnproto-rust allocates message buffers using this type,
/// to guarantee alignment.
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(C, align(8))]
pub struct Word {
    raw_content: [u8; 8]
}

///
/// Constructs a word with the given bytes.
///
pub const fn word(b0: u8, b1: u8, b2: u8, b3: u8, b4: u8, b5: u8, b6: u8, b7: u8) -> Word {
    Word { raw_content: [b0,b1,b2,b3,b4,b5,b6,b7] }
}

impl Word {
    /// Does this, but faster: `vec![word(0,0,0,0,0,0,0,0); length]`.
    pub fn allocate_zeroed_vec(length: usize) -> Vec<Word> {
        let mut result: Vec<Word> = Vec::with_capacity(length);
        unsafe {
            result.set_len(length);
            let p: *mut u8 = result.as_mut_ptr() as *mut u8;
            core::ptr::write_bytes(p, 0u8, length * core::mem::size_of::<Word>());
        }
        result
    }

    pub fn words_to_bytes<'a>(words: &'a [Word]) -> &'a [u8] {
        unsafe {
            core::slice::from_raw_parts(words.as_ptr() as *const u8, words.len() * 8)
        }
    }

    pub fn words_to_bytes_mut<'a>(words: &'a mut [Word]) -> &'a mut [u8] {
        unsafe {
            core::slice::from_raw_parts_mut(words.as_mut_ptr() as *mut u8, words.len() * 8)
        }
    }
}

#[cfg(any(feature="quickcheck", test))]
impl quickcheck::Arbitrary for Word {
    fn arbitrary<G: quickcheck::Gen>(g: &mut G) -> Word {
        crate::word(quickcheck::Arbitrary::arbitrary(g),
                    quickcheck::Arbitrary::arbitrary(g),
                    quickcheck::Arbitrary::arbitrary(g),
                    quickcheck::Arbitrary::arbitrary(g),
                    quickcheck::Arbitrary::arbitrary(g),
                    quickcheck::Arbitrary::arbitrary(g),
                    quickcheck::Arbitrary::arbitrary(g),
                    quickcheck::Arbitrary::arbitrary(g))
    }
}

/// Size of a message. Every generated struct has a method `.total_size()` that returns this.
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct MessageSize {
    pub word_count: u64,

    /// Size of the capability table.
    pub cap_count: u32
}

impl MessageSize {
    pub fn plus_eq(&mut self, other : MessageSize) {
        self.word_count += other.word_count;
        self.cap_count += other.cap_count;
    }
}

/// An enum value or union discriminant that was not found among those defined in a schema.
#[derive(PartialEq, Clone, Copy, Debug)]
pub struct NotInSchema(pub u16);

impl ::core::fmt::Display for NotInSchema {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter) -> ::core::result::Result<(), ::core::fmt::Error> {
        write!(fmt, "Enum value or union discriminant {} was not present in the schema.", self.0)
    }
}

#[cfg(feature="std")]
impl ::std::error::Error for NotInSchema {
    fn description<'a>(&'a self) -> &'a str {
        "Enum value or union discriminant was not present in schema."
    }
}

/// Because messages are lazily validated, the return type of any method that reads a pointer field
/// must be wrapped in a Result.
pub type Result<T> = ::core::result::Result<T, Error>;

/// Describes an arbitrary error that prevented an operation from completing.
#[derive(Debug, Clone)]
pub struct Error {
    /// The general kind of the error. Code that decides how to respond to an error
    /// should read only this field in making its decision.
    pub kind: ErrorKind,

    /// Human-readable failure description.
    pub description: String,
}

/// The general nature of an error. The purpose of this enum is not to describe the error itself,
/// but rather to describe how the client might want to respond to the error.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ErrorKind {
    /// Something went wrong. This is the usual error kind. It includes decoding errors.
    Failed,

    /// The call failed because of a temporary lack of resources. This could be space resources
    /// (out of memory, out of disk space) or time resources (request queue overflow, operation
    /// timed out).
    ///
    /// The operation might work if tried again, but it should NOT be repeated immediately as this
    /// may simply exacerbate the problem.
    Overloaded,

    /// The call required communication over a connection that has been lost. The callee will need
    /// to re-establish connections and try again.
    Disconnected,

    /// The requested method is not implemented. The caller may wish to revert to a fallback
    /// approach based on other methods.
    Unimplemented,
}

impl Error {
    pub fn failed(description: String) -> Error {
        Error { description: description, kind: ErrorKind::Failed }
    }
    pub fn overloaded(description: String) -> Error {
        Error { description: description, kind: ErrorKind::Overloaded }
    }
    pub fn disconnected(description: String) -> Error {
        Error { description: description, kind: ErrorKind::Disconnected }
    }
    pub fn unimplemented(description: String) -> Error {
        Error { description: description, kind: ErrorKind::Unimplemented }
    }
}

#[cfg(feature="std")]
impl core::convert::From<::std::io::Error> for Error {
    fn from(err: ::std::io::Error) -> Error {
        use std::io;
        let kind = match err.kind() {
            io::ErrorKind::TimedOut => ErrorKind::Overloaded,
            io::ErrorKind::BrokenPipe |
            io::ErrorKind::ConnectionRefused |
            io::ErrorKind::ConnectionReset |
            io::ErrorKind::ConnectionAborted |
            io::ErrorKind::NotConnected  => ErrorKind::Disconnected,
            _ => ErrorKind::Failed,
        };
        Error { description: format!("{}", err), kind: kind }
    }
}

impl core::convert::From<alloc::string::FromUtf8Error> for Error {
    fn from(err: alloc::string::FromUtf8Error) -> Error {
        Error::failed(format!("{}", err))
    }
}

impl core::convert::From<alloc::str::Utf8Error> for Error {
    fn from(err: alloc::str::Utf8Error) -> Error {
        Error::failed(format!("{}", err))
    }
}

impl core::convert::From<NotInSchema> for Error {
    fn from(e: NotInSchema) -> Error {
        Error::failed(format!("Enum value or union discriminant {} was not present in schema.", e.0))
    }
}

impl core::fmt::Display for Error {
    fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::result::Result<(), core::fmt::Error> {
        write!(fmt, "{:?}: {}", self.kind, self.description)
    }
}

#[cfg(feature="std")]
impl ::std::error::Error for Error {
    fn description(&self) -> &str {
        &self.description
    }
    fn cause(&self) -> Option<&dyn (::std::error::Error)> {
        None
    }
}

/// Helper struct that allows `MessageBuilder::get_segments_for_output()` to avoid heap allocations
/// in the single-segment case.
pub enum OutputSegments<'a> {
    SingleSegment([&'a [u8]; 1]),
    MultiSegment(Vec<&'a [u8]>),
}

impl <'a> core::ops::Deref for OutputSegments<'a> {
    type Target = [&'a [u8]];
    fn deref<'b>(&'b self) -> &'b [&'a [u8]] {
        match *self {
            OutputSegments::SingleSegment(ref s) => {
                s
            }
            OutputSegments::MultiSegment(ref v) => {
                v
            }
        }
    }
}

impl<'s> message::ReaderSegments for OutputSegments<'s> {
    fn get_segment<'a>(&'a self, id: u32) -> Option<&'a [u8]> {
        match *self {
            OutputSegments::SingleSegment(ref s) => {
                s.get(id as usize).map(|slice| *slice)
            }
            OutputSegments::MultiSegment(ref v) => {
                v.get(id as usize).map(|slice| *slice)
            }
        }
    }
}
